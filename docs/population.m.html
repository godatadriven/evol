<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>evol.population API documentation</title>
    <meta name="description" content="Population objects in `evol` are a collection of chromosomes
at some point in an evolutionary algori..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#evol.population.ContestPopulation">ContestPopulation</a></span>
        
          
  <ul>
    <li class="mono"><a href="#evol.population.ContestPopulation.__init__">__init__</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.apply">apply</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.breed">breed</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.callback">callback</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.checkpoint">checkpoint</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.evaluate">evaluate</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.evolve">evolve</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.filter">filter</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.log">log</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.map">map</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.mutate">mutate</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.reset_fitness">reset_fitness</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.survive">survive</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.generate">generate</a></li>
    <li class="mono"><a href="#evol.population.ContestPopulation.load">load</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#evol.population.Population">Population</a></span>
        
          
  <ul>
    <li class="mono"><a href="#evol.population.Population.__init__">__init__</a></li>
    <li class="mono"><a href="#evol.population.Population.apply">apply</a></li>
    <li class="mono"><a href="#evol.population.Population.breed">breed</a></li>
    <li class="mono"><a href="#evol.population.Population.callback">callback</a></li>
    <li class="mono"><a href="#evol.population.Population.checkpoint">checkpoint</a></li>
    <li class="mono"><a href="#evol.population.Population.evaluate">evaluate</a></li>
    <li class="mono"><a href="#evol.population.Population.evolve">evolve</a></li>
    <li class="mono"><a href="#evol.population.Population.filter">filter</a></li>
    <li class="mono"><a href="#evol.population.Population.log">log</a></li>
    <li class="mono"><a href="#evol.population.Population.map">map</a></li>
    <li class="mono"><a href="#evol.population.Population.mutate">mutate</a></li>
    <li class="mono"><a href="#evol.population.Population.survive">survive</a></li>
    <li class="mono"><a href="#evol.population.Population.generate">generate</a></li>
    <li class="mono"><a href="#evol.population.Population.load">load</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">evol.population</span> module</h1>
  <p>Population objects in <code>evol</code> are a collection of chromosomes
at some point in an evolutionary algorithm. You can apply
evolutionary steps by directly calling methods on the population
or by appyling an <code>evol.Evolution</code> object.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population', this);">Show source &equiv;</a></p>
  <div id="source-evol.population" class="source">
    <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Population objects in `evol` are a collection of chromosomes</span>
<span class="sd">at some point in an evolutionary algorithm. You can apply</span>
<span class="sd">evolutionary steps by directly calling methods on the population</span>
<span class="sd">or by appyling an `evol.Evolution` object.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">cycle</span><span class="p">,</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">uuid</span> <span class="kn">import</span> <span class="n">uuid4</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">choices</span><span class="p">,</span> <span class="n">randint</span>

<span class="kn">from</span> <span class="nn">evol</span> <span class="kn">import</span> <span class="n">Individual</span>
<span class="kn">from</span> <span class="nn">evol.helpers.utils</span> <span class="kn">import</span> <span class="n">select_arguments</span><span class="p">,</span> <span class="n">offspring_generator</span>
<span class="kn">from</span> <span class="nn">evol.logger</span> <span class="kn">import</span> <span class="n">BaseLogger</span>
<span class="kn">from</span> <span class="nn">evol.serialization</span> <span class="kn">import</span> <span class="n">SimpleSerializer</span>


<span class="k">class</span> <span class="nc">Population</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Population of Individuals</span>

<span class="sd">    :param chromosomes: Iterable of initial chromosomes of the Population.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param maximize: If True, fitness will be maximized, otherwise minimized.</span>
<span class="sd">        Defaults to True.</span>
<span class="sd">    :param logger: Logger object for the Population. If None, a new BaseLogger</span>
<span class="sd">        is created. Defaults to None.</span>
<span class="sd">    :param generation: Generation of the Population. Defaults to 0.</span>
<span class="sd">    :param intended_size: Intended size of the Population. The population will</span>
<span class="sd">        be replenished to this size by .breed(). Defaults to the number of</span>
<span class="sd">        chromosomes provided.</span>
<span class="sd">    :param checkpoint_target: Target for the serializer of the Population. If</span>
<span class="sd">        a serializer is provided, this target is ignored. Defaults to None.</span>
<span class="sd">    :param serializer: Serializer for the Population. If None, a new</span>
<span class="sd">        SimpleSerializer is created. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">chromosomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
                 <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">maximize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">generation</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">intended_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">checkpoint_target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">serializer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid4</span><span class="p">())[:</span><span class="mi">6</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span> <span class="o">=</span> <span class="n">eval_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generation</span> <span class="o">=</span> <span class="n">generation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Individual</span><span class="p">(</span><span class="n">chromosome</span><span class="o">=</span><span class="n">chromosome</span><span class="p">)</span> <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">chromosomes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">=</span> <span class="n">intended_size</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="o">=</span> <span class="n">maximize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span> <span class="ow">or</span> <span class="n">BaseLogger</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span> <span class="o">=</span> <span class="n">serializer</span> <span class="ow">or</span> <span class="n">SimpleSerializer</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">checkpoint_target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chromosomes</span><span class="p">,</span>
                                <span class="n">eval_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">,</span>
                                <span class="n">maximize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">,</span>
                                <span class="n">serializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="p">,</span>
                                <span class="n">intended_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span><span class="p">,</span>
                                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                                <span class="n">generation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Individual</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Individual</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;Population with size {len(self)} at {id(self)}&gt;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Individual</span><span class="p">:</span>
        <span class="n">evaluated_individuals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_worst</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Individual</span><span class="p">:</span>
        <span class="n">evaluated_individuals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chromosomes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">individual</span><span class="o">.</span><span class="n">chromosome</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                 <span class="n">init_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">],</span>
                 <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generate a population from an initialisation function.</span>

<span class="sd">        :param init_function: Function that returns a chromosome.</span>
<span class="sd">        :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">        :param size: Number of individuals to generate. Defaults to 100.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chromosomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_function</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="n">chromosomes</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
             <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Load a population from a checkpoint.</span>

<span class="sd">        :param target: Path to checkpoint directory or file.</span>
<span class="sd">        :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">        :param kwargs: Any argument the init method accepts.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="p">[],</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;pickle&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Checkpoint the population.</span>

<span class="sd">        :param target: Directory to write checkpoint to. If None, the Serializer default target is taken,</span>
<span class="sd">            which can be provided upon initialisation. Defaults to None.</span>
<span class="sd">        :param method: One of &#39;pickle&#39; or &#39;json&#39;. When &#39;json&#39;, the chromosomes need to be json-serializable.</span>
<span class="sd">            Defaults to &#39;pickle&#39;.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">individuals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_individual_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">min_fitness</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">max_fitness</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Individual weights can not be computed if the individuals are not evaluated.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_fitness</span> <span class="o">==</span> <span class="n">max_fitness</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evolution</span><span class="p">:</span> <span class="s1">&#39;Evolution&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evolve the population according to an Evolution.</span>

<span class="sd">        :param evolution: Evolution to follow</span>
<span class="sd">        :param n: Times to apply the evolution. Defaults to 1.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">evo_batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">evolution</span><span class="p">:</span>
                <span class="n">step</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the individuals in the population.</span>

<span class="sd">        This evaluates the fitness of all individuals. If lazy is True, the</span>
<span class="sd">        fitness is only evaluated when a fitness value is not yet known. In</span>
<span class="sd">        most situations adding an explicit evaluation step is not needed, as</span>
<span class="sd">        lazy evaluation is implicitly included in the operations that need it</span>
<span class="sd">        (most notably in the survive operation).</span>

<span class="sd">        :param lazy: If True, do no re-evaluate the fitness if the fitness is known.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">eval_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="n">lazy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_documented_best</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the provided function to the population.</span>

<span class="sd">        :param func: A function to apply to the population, which returns the (modified) population.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Individual</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the provided function to each individual in the population.</span>

<span class="sd">        :param func: A function to apply to each individual in the population,</span>
<span class="sd">            which when called returns a modified individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">individual</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a filter step to the Evolution.</span>

<span class="sd">        Filters the individuals in the population using the provided function.</span>

<span class="sd">        :param func: Function to filter the individuals in the population by,</span>
<span class="sd">            which returns a boolean when called on an individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">individual</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">individual</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">luck</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Let part of the population survive.</span>

<span class="sd">        Remove part of the population. If both fraction and n are specified,</span>
<span class="sd">        the minimum resulting population size is taken.</span>

<span class="sd">        :param fraction: Fraction of the original population that survives.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param n: Number of individuals of the population that survive.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param luck: If True, individuals randomly survive (with replacement!)</span>
<span class="sd">            with chances proportional to their fitness. Defaults to False.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fraction</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;everyone survives! must provide either &quot;fraction&quot; and/or &quot;n&quot;.&#39;</span><span class="p">)</span>
            <span class="n">resulting_size</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">resulting_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resulting_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)),</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resulting_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no one survived!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resulting_size</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;everyone survives! must provide &quot;fraction&quot; and/or &quot;n&quot; &lt; population size&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">luck</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">choices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">resulting_size</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_individual_weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_individuals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">sorted_individuals</span><span class="p">[:</span><span class="n">resulting_size</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">breed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">parent_picker</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Individual</span><span class="p">]],</span>
              <span class="n">combiner</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
              <span class="n">population_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create new individuals by combining existing individuals.</span>

<span class="sd">        :param parent_picker: Function that selects parents from a collection of individuals.</span>
<span class="sd">        :param combiner: Function that combines chromosomes into a new</span>
<span class="sd">            chromosome. Must be able to handle the number of chromosomes</span>
<span class="sd">            that the combiner returns.</span>
<span class="sd">        :param population_size: Intended population size after breeding.</span>
<span class="sd">            If None, take the previous intended population size.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param kwargs: Kwargs to pass to the parent_picker and combiner.</span>
<span class="sd">            Arguments are only passed to the functions if they accept them.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">population_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">=</span> <span class="n">population_size</span>
        <span class="n">offspring</span> <span class="o">=</span> <span class="n">offspring_generator</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
                                        <span class="n">parent_picker</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">parent_picker</span><span class="p">),</span>
                                        <span class="n">combiner</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">combiner</span><span class="p">),</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">mutate_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
               <span class="n">probability</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Mutate the chromosome of each individual.</span>

<span class="sd">        :param mutate_function: Function that accepts a chromosome and returns</span>
<span class="sd">            a mutated chromosome.</span>
<span class="sd">        :param probability: Probability that the individual mutates.</span>
<span class="sd">            The function is only applied in the given fraction of cases.</span>
<span class="sd">            Defaults to 1.0.</span>
<span class="sd">        :param kwargs: Arguments to pass to the mutation function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">mutate_function</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs a population. If a Population object was initialized with a logger</span>
<span class="sd">        object then you may specify how logging is handled. The base logging</span>
<span class="sd">        operation just logs to standard out.</span>

<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="bp">None</span><span class="p">],</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a callback function on the population. Can be used for</span>
<span class="sd">        custom logging/checkpointing.</span>
<span class="sd">        :param callback_function: Function that accepts the population</span>
<span class="sd">        as a first argument.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">callback_function</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_update_documented_best</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the documented best&quot;&quot;&quot;</span>
        <span class="n">current_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_best</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="ow">and</span> <span class="n">current_best</span><span class="o">.</span><span class="n">fitness</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="ow">and</span> <span class="n">current_best</span><span class="o">.</span><span class="n">fitness</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span><span class="o">.</span><span class="n">fitness</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">current_best</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ContestPopulation</span><span class="p">(</span><span class="n">Population</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Population which is evaluated through contests.</span>

<span class="sd">    This variant of the Population is used when individuals cannot be</span>
<span class="sd">    evaluated on a one-by-one basis, but instead can only be compared to</span>
<span class="sd">    each other. This is typically the case for AI that performs some task</span>
<span class="sd">    (i.e. plays a game), but can be useful in many other cases.</span>

<span class="sd">    For each round of evaluation, each individual participates in a given</span>
<span class="sd">    number of contests, in which a given number of individuals take part.</span>
<span class="sd">    The resulting scores of these contests are summed to form the fitness.</span>

<span class="sd">    Since the fitness of an individual is dependent on the other individuals</span>
<span class="sd">    in the population, the fitness of all individuals is recalculated when</span>
<span class="sd">    new individuals are present, and the fitness of all individuals is reset</span>
<span class="sd">    when the population is modified (e.g. by calling survive, mutate etc).</span>

<span class="sd">    :param chromosomes: Iterable of initial chromosomes of the Population.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param maximize: If True, fitness will be maximized, otherwise minimized.</span>
<span class="sd">        Defaults to True.</span>
<span class="sd">    :param contests_per_round: Number of contests each individual takes part</span>
<span class="sd">        in for each evaluation round. Defaults to 10.</span>
<span class="sd">    :param individuals_per_contest: Number of individuals that take part in</span>
<span class="sd">        each contest. The size of the population must be divisible by this</span>
<span class="sd">        number. Defaults to 2.</span>
<span class="sd">    :param logger: Logger object for the Population. If None, a new BaseLogger</span>
<span class="sd">        is created. Defaults to None.</span>
<span class="sd">    :param generation: Generation of the Population. Defaults to 0.</span>
<span class="sd">    :param intended_size: Intended size of the Population. The population will</span>
<span class="sd">        be replenished to this size by .breed(). Defaults to the number of</span>
<span class="sd">        chromosomes provided.</span>
<span class="sd">    :param checkpoint_target: Target for the serializer of the Population. If</span>
<span class="sd">        a serializer is provided, this target is ignored. Defaults to None.</span>
<span class="sd">    :param serializer: Serializer for the Population. If None, a new</span>
<span class="sd">        SimpleSerializer is created. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">chromosomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
                 <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
                 <span class="n">maximize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">contests_per_round</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">individuals_per_contest</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">generation</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">intended_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">checkpoint_target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">serializer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">Population</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromosomes</span><span class="o">=</span><span class="n">chromosomes</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="n">maximize</span><span class="o">=</span><span class="n">maximize</span><span class="p">,</span>
                            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">generation</span><span class="o">=</span><span class="n">generation</span><span class="p">,</span> <span class="n">intended_size</span><span class="o">=</span><span class="n">intended_size</span><span class="p">,</span>
                            <span class="n">checkpoint_target</span><span class="o">=</span><span class="n">checkpoint_target</span><span class="p">,</span> <span class="n">serializer</span><span class="o">=</span><span class="n">serializer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span> <span class="o">=</span> <span class="n">contests_per_round</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span> <span class="o">=</span> <span class="n">individuals_per_contest</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chromosomes</span><span class="p">,</span>
                                <span class="n">eval_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">,</span>
                                <span class="n">maximize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">,</span>
                                <span class="n">contests_per_round</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span><span class="p">,</span>
                                <span class="n">individuals_per_contest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span><span class="p">,</span>
                                <span class="n">serializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="p">,</span>
                                <span class="n">intended_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span><span class="p">,</span>
                                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                                <span class="n">generation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">contests_per_round</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">individuals_per_contest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ContestPopulation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the individuals in the population.</span>

<span class="sd">        This evaluates the fitness of all individuals. For each round of</span>
<span class="sd">        evaluation, each individual participates in a given number of</span>
<span class="sd">        contests, in which a given number of individuals take part.</span>
<span class="sd">        The resulting scores of these contests are summed to form the fitness.</span>
<span class="sd">        This means that the score of the individual is influenced by other</span>
<span class="sd">        chromosomes in the population.</span>

<span class="sd">        Note that in the `ContestPopulation` two settings are passed at</span>
<span class="sd">        initialisation which affect how we are evaluating individuals:</span>
<span class="sd">        contests_per_round and individuals_per_contest. You may overwrite them</span>
<span class="sd">        here if you wish.</span>

<span class="sd">        If lazy is True, the fitness is only evaluated when a fitness value</span>
<span class="sd">        is not yet known for all individuals.</span>
<span class="sd">        In most situations adding an explicit evaluation step is not needed, as</span>
<span class="sd">        lazy evaluation is implicitly included in the operations that need it</span>
<span class="sd">        (most notably in the survive operation).</span>

<span class="sd">        :param lazy: If True, do no re-evaluate the fitness if the fitness is known.</span>
<span class="sd">        :param contests_per_round: If set, overwrites the population setting for the</span>
<span class="sd">        number of contests there will be every round.</span>
<span class="sd">        :param individuals_per_contest: If set, overwrites the population setting for</span>
<span class="sd">        number of individuals to have in a contest during the evaluation.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">contests_per_round</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">contests_per_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span>
        <span class="k">if</span> <span class="n">individuals_per_contest</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">individuals_per_contest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span>
        <span class="k">if</span> <span class="n">lazy</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">contests_per_round</span><span class="p">):</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">individuals_per_contest</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">generators</span> <span class="o">=</span> <span class="p">[</span><span class="n">islice</span><span class="p">(</span><span class="n">cycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">),</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">competitors</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">generators</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)):</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">(</span><span class="o">*</span><span class="n">competitors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">competitor</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">competitors</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
                    <span class="n">competitor</span><span class="o">.</span><span class="n">fitness</span> <span class="o">+=</span> <span class="n">score</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Individual</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the provided function to each individual in the population.</span>

<span class="sd">        Resets the fitness of all individuals.</span>

<span class="sd">        :param func: A function to apply to each individual in the population,</span>
<span class="sd">            which when called returns a modified individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Population</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a filter step to the Evolution.</span>

<span class="sd">        Filters the individuals in the population using the provided function.</span>
<span class="sd">        Resets the fitness of all individuals.</span>

<span class="sd">        :param func: Function to filter the individuals in the population by,</span>
<span class="sd">            which returns a boolean when called on an individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Population</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">luck</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ContestPopulation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Let part of the population survive.</span>

<span class="sd">        Remove part of the population. If both fraction and n are specified,</span>
<span class="sd">        the minimum resulting population size is taken. Resets the fitness</span>
<span class="sd">        of all individuals.</span>

<span class="sd">        :param fraction: Fraction of the original population that survives.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param n: Number of individuals of the population that survive.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param luck: If True, individuals randomly survive (with replacement!)</span>
<span class="sd">            with chances proportional to their fitness. Defaults to False.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Population</span><span class="o">.</span><span class="n">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">fraction</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">luck</span><span class="o">=</span><span class="n">luck</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># If we return the result of Population.survive PyCharm complains that it is of type &#39;Population&#39;</span>

    <span class="k">def</span> <span class="nf">reset_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the fitness of all individuals.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="evol.population.ContestPopulation" class="name">class <span class="ident">ContestPopulation</span></p>
      
  
    <div class="desc"><p>Population which is evaluated through contests.</p>
<p>This variant of the Population is used when individuals cannot be
evaluated on a one-by-one basis, but instead can only be compared to
each other. This is typically the case for AI that performs some task
(i.e. plays a game), but can be useful in many other cases.</p>
<p>For each round of evaluation, each individual participates in a given
number of contests, in which a given number of individuals take part.
The resulting scores of these contests are summed to form the fitness.</p>
<p>Since the fitness of an individual is dependent on the other individuals
in the population, the fitness of all individuals is recalculated when
new individuals are present, and the fitness of all individuals is reset
when the population is modified (e.g. by calling survive, mutate etc).</p>
<p>:param chromosomes: Iterable of initial chromosomes of the Population.
:param eval_function: Function that reduces a chromosome to a fitness.
:param maximize: If True, fitness will be maximized, otherwise minimized.
    Defaults to True.
:param contests_per_round: Number of contests each individual takes part
    in for each evaluation round. Defaults to 10.
:param individuals_per_contest: Number of individuals that take part in
    each contest. The size of the population must be divisible by this
    number. Defaults to 2.
:param logger: Logger object for the Population. If None, a new BaseLogger
    is created. Defaults to None.
:param generation: Generation of the Population. Defaults to 0.
:param intended_size: Intended size of the Population. The population will
    be replenished to this size by .breed(). Defaults to the number of
    chromosomes provided.
:param checkpoint_target: Target for the serializer of the Population. If
    a serializer is provided, this target is ignored. Defaults to None.
:param serializer: Serializer for the Population. If None, a new
    SimpleSerializer is created. Defaults to None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ContestPopulation</span><span class="p">(</span><span class="n">Population</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Population which is evaluated through contests.</span>

<span class="sd">    This variant of the Population is used when individuals cannot be</span>
<span class="sd">    evaluated on a one-by-one basis, but instead can only be compared to</span>
<span class="sd">    each other. This is typically the case for AI that performs some task</span>
<span class="sd">    (i.e. plays a game), but can be useful in many other cases.</span>

<span class="sd">    For each round of evaluation, each individual participates in a given</span>
<span class="sd">    number of contests, in which a given number of individuals take part.</span>
<span class="sd">    The resulting scores of these contests are summed to form the fitness.</span>

<span class="sd">    Since the fitness of an individual is dependent on the other individuals</span>
<span class="sd">    in the population, the fitness of all individuals is recalculated when</span>
<span class="sd">    new individuals are present, and the fitness of all individuals is reset</span>
<span class="sd">    when the population is modified (e.g. by calling survive, mutate etc).</span>

<span class="sd">    :param chromosomes: Iterable of initial chromosomes of the Population.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param maximize: If True, fitness will be maximized, otherwise minimized.</span>
<span class="sd">        Defaults to True.</span>
<span class="sd">    :param contests_per_round: Number of contests each individual takes part</span>
<span class="sd">        in for each evaluation round. Defaults to 10.</span>
<span class="sd">    :param individuals_per_contest: Number of individuals that take part in</span>
<span class="sd">        each contest. The size of the population must be divisible by this</span>
<span class="sd">        number. Defaults to 2.</span>
<span class="sd">    :param logger: Logger object for the Population. If None, a new BaseLogger</span>
<span class="sd">        is created. Defaults to None.</span>
<span class="sd">    :param generation: Generation of the Population. Defaults to 0.</span>
<span class="sd">    :param intended_size: Intended size of the Population. The population will</span>
<span class="sd">        be replenished to this size by .breed(). Defaults to the number of</span>
<span class="sd">        chromosomes provided.</span>
<span class="sd">    :param checkpoint_target: Target for the serializer of the Population. If</span>
<span class="sd">        a serializer is provided, this target is ignored. Defaults to None.</span>
<span class="sd">    :param serializer: Serializer for the Population. If None, a new</span>
<span class="sd">        SimpleSerializer is created. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">chromosomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
                 <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
                 <span class="n">maximize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">contests_per_round</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                 <span class="n">individuals_per_contest</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                 <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">generation</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">intended_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">checkpoint_target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">serializer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">Population</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromosomes</span><span class="o">=</span><span class="n">chromosomes</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="n">maximize</span><span class="o">=</span><span class="n">maximize</span><span class="p">,</span>
                            <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">generation</span><span class="o">=</span><span class="n">generation</span><span class="p">,</span> <span class="n">intended_size</span><span class="o">=</span><span class="n">intended_size</span><span class="p">,</span>
                            <span class="n">checkpoint_target</span><span class="o">=</span><span class="n">checkpoint_target</span><span class="p">,</span> <span class="n">serializer</span><span class="o">=</span><span class="n">serializer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span> <span class="o">=</span> <span class="n">contests_per_round</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span> <span class="o">=</span> <span class="n">individuals_per_contest</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chromosomes</span><span class="p">,</span>
                                <span class="n">eval_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">,</span>
                                <span class="n">maximize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">,</span>
                                <span class="n">contests_per_round</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span><span class="p">,</span>
                                <span class="n">individuals_per_contest</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span><span class="p">,</span>
                                <span class="n">serializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="p">,</span>
                                <span class="n">intended_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span><span class="p">,</span>
                                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                                <span class="n">generation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">contests_per_round</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">individuals_per_contest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ContestPopulation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the individuals in the population.</span>

<span class="sd">        This evaluates the fitness of all individuals. For each round of</span>
<span class="sd">        evaluation, each individual participates in a given number of</span>
<span class="sd">        contests, in which a given number of individuals take part.</span>
<span class="sd">        The resulting scores of these contests are summed to form the fitness.</span>
<span class="sd">        This means that the score of the individual is influenced by other</span>
<span class="sd">        chromosomes in the population.</span>

<span class="sd">        Note that in the `ContestPopulation` two settings are passed at</span>
<span class="sd">        initialisation which affect how we are evaluating individuals:</span>
<span class="sd">        contests_per_round and individuals_per_contest. You may overwrite them</span>
<span class="sd">        here if you wish.</span>

<span class="sd">        If lazy is True, the fitness is only evaluated when a fitness value</span>
<span class="sd">        is not yet known for all individuals.</span>
<span class="sd">        In most situations adding an explicit evaluation step is not needed, as</span>
<span class="sd">        lazy evaluation is implicitly included in the operations that need it</span>
<span class="sd">        (most notably in the survive operation).</span>

<span class="sd">        :param lazy: If True, do no re-evaluate the fitness if the fitness is known.</span>
<span class="sd">        :param contests_per_round: If set, overwrites the population setting for the</span>
<span class="sd">        number of contests there will be every round.</span>
<span class="sd">        :param individuals_per_contest: If set, overwrites the population setting for</span>
<span class="sd">        number of individuals to have in a contest during the evaluation.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">contests_per_round</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">contests_per_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span>
        <span class="k">if</span> <span class="n">individuals_per_contest</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">individuals_per_contest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span>
        <span class="k">if</span> <span class="n">lazy</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">contests_per_round</span><span class="p">):</span>
            <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">individuals_per_contest</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">generators</span> <span class="o">=</span> <span class="p">[</span><span class="n">islice</span><span class="p">(</span><span class="n">cycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">),</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">competitors</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">generators</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)):</span>
                <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">(</span><span class="o">*</span><span class="n">competitors</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">competitor</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">competitors</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
                    <span class="n">competitor</span><span class="o">.</span><span class="n">fitness</span> <span class="o">+=</span> <span class="n">score</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Individual</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the provided function to each individual in the population.</span>

<span class="sd">        Resets the fitness of all individuals.</span>

<span class="sd">        :param func: A function to apply to each individual in the population,</span>
<span class="sd">            which when called returns a modified individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Population</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a filter step to the Evolution.</span>

<span class="sd">        Filters the individuals in the population using the provided function.</span>
<span class="sd">        Resets the fitness of all individuals.</span>

<span class="sd">        :param func: Function to filter the individuals in the population by,</span>
<span class="sd">            which returns a boolean when called on an individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Population</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">luck</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ContestPopulation&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Let part of the population survive.</span>

<span class="sd">        Remove part of the population. If both fraction and n are specified,</span>
<span class="sd">        the minimum resulting population size is taken. Resets the fitness</span>
<span class="sd">        of all individuals.</span>

<span class="sd">        :param fraction: Fraction of the original population that survives.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param n: Number of individuals of the population that survive.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param luck: If True, individuals randomly survive (with replacement!)</span>
<span class="sd">            with chances proportional to their fitness. Defaults to False.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Population</span><span class="o">.</span><span class="n">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">fraction</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">luck</span><span class="o">=</span><span class="n">luck</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># If we return the result of Population.survive PyCharm complains that it is of type &#39;Population&#39;</span>

    <span class="k">def</span> <span class="nf">reset_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the fitness of all individuals.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#evol.population.ContestPopulation">ContestPopulation</a></li>
          <li><a href="#evol.population.Population">Population</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, chromosomes, eval_function, maximize=True, contests_per_round=10, individuals_per_contest=2, logger=None, generation=0, intended_size=None, checkpoint_target=None, serializer=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.__init__', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">chromosomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
             <span class="n">maximize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="n">contests_per_round</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
             <span class="n">individuals_per_contest</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
             <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">generation</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">intended_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">checkpoint_target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">serializer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">Population</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chromosomes</span><span class="o">=</span><span class="n">chromosomes</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="n">maximize</span><span class="o">=</span><span class="n">maximize</span><span class="p">,</span>
                        <span class="n">logger</span><span class="o">=</span><span class="n">logger</span><span class="p">,</span> <span class="n">generation</span><span class="o">=</span><span class="n">generation</span><span class="p">,</span> <span class="n">intended_size</span><span class="o">=</span><span class="n">intended_size</span><span class="p">,</span>
                        <span class="n">checkpoint_target</span><span class="o">=</span><span class="n">checkpoint_target</span><span class="p">,</span> <span class="n">serializer</span><span class="o">=</span><span class="n">serializer</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span> <span class="o">=</span> <span class="n">contests_per_round</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span> <span class="o">=</span> <span class="n">individuals_per_contest</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.apply">
    <p>def <span class="ident">apply</span>(</p><p>self, func, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Apply the provided function to the population.</p>
<p>:param func: A function to apply to the population, which returns the (modified) population.
:param kwargs: Arguments to pass to the function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.apply', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.apply" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Apply the provided function to the population.</span>
<span class="sd">    :param func: A function to apply to the population, which returns the (modified) population.</span>
<span class="sd">    :param kwargs: Arguments to pass to the function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.breed">
    <p>def <span class="ident">breed</span>(</p><p>self, parent_picker, combiner, population_size=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Create new individuals by combining existing individuals.</p>
<p>:param parent_picker: Function that selects parents from a collection of individuals.
:param combiner: Function that combines chromosomes into a new
    chromosome. Must be able to handle the number of chromosomes
    that the combiner returns.
:param population_size: Intended population size after breeding.
    If None, take the previous intended population size.
    Defaults to None.
:param kwargs: Kwargs to pass to the parent_picker and combiner.
    Arguments are only passed to the functions if they accept them.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.breed', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.breed" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">breed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
          <span class="n">parent_picker</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Individual</span><span class="p">]],</span>
          <span class="n">combiner</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
          <span class="n">population_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create new individuals by combining existing individuals.</span>
<span class="sd">    :param parent_picker: Function that selects parents from a collection of individuals.</span>
<span class="sd">    :param combiner: Function that combines chromosomes into a new</span>
<span class="sd">        chromosome. Must be able to handle the number of chromosomes</span>
<span class="sd">        that the combiner returns.</span>
<span class="sd">    :param population_size: Intended population size after breeding.</span>
<span class="sd">        If None, take the previous intended population size.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    :param kwargs: Kwargs to pass to the parent_picker and combiner.</span>
<span class="sd">        Arguments are only passed to the functions if they accept them.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">population_size</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">=</span> <span class="n">population_size</span>
    <span class="n">offspring</span> <span class="o">=</span> <span class="n">offspring_generator</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
                                    <span class="n">parent_picker</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">parent_picker</span><span class="p">),</span>
                                    <span class="n">combiner</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">combiner</span><span class="p">),</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)))</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.callback">
    <p>def <span class="ident">callback</span>(</p><p>self, callback_function, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a callback function on the population. Can be used for
custom logging/checkpointing.
:param callback_function: Function that accepts the population
as a first argument.
:return:</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.callback', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.callback" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="bp">None</span><span class="p">],</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a callback function on the population. Can be used for</span>
<span class="sd">    custom logging/checkpointing.</span>
<span class="sd">    :param callback_function: Function that accepts the population</span>
<span class="sd">    as a first argument.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">callback_function</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.checkpoint">
    <p>def <span class="ident">checkpoint</span>(</p><p>self, target=None, method=&#39;pickle&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Checkpoint the population.</p>
<p>:param target: Directory to write checkpoint to. If None, the Serializer default target is taken,
    which can be provided upon initialisation. Defaults to None.
:param method: One of 'pickle' or 'json'. When 'json', the chromosomes need to be json-serializable.
    Defaults to 'pickle'.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.checkpoint" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;pickle&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Checkpoint the population.</span>
<span class="sd">    :param target: Directory to write checkpoint to. If None, the Serializer default target is taken,</span>
<span class="sd">        which can be provided upon initialisation. Defaults to None.</span>
<span class="sd">    :param method: One of &#39;pickle&#39; or &#39;json&#39;. When &#39;json&#39;, the chromosomes need to be json-serializable.</span>
<span class="sd">        Defaults to &#39;pickle&#39;.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">individuals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.evaluate">
    <p>def <span class="ident">evaluate</span>(</p><p>self, lazy=False, contests_per_round=None, individuals_per_contest=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluate the individuals in the population.</p>
<p>This evaluates the fitness of all individuals. For each round of
evaluation, each individual participates in a given number of
contests, in which a given number of individuals take part.
The resulting scores of these contests are summed to form the fitness.
This means that the score of the individual is influenced by other
chromosomes in the population.</p>
<p>Note that in the <code>ContestPopulation</code> two settings are passed at
initialisation which affect how we are evaluating individuals:
contests_per_round and individuals_per_contest. You may overwrite them
here if you wish.</p>
<p>If lazy is True, the fitness is only evaluated when a fitness value
is not yet known for all individuals.
In most situations adding an explicit evaluation step is not needed, as
lazy evaluation is implicitly included in the operations that need it
(most notably in the survive operation).</p>
<p>:param lazy: If True, do no re-evaluate the fitness if the fitness is known.
:param contests_per_round: If set, overwrites the population setting for the
number of contests there will be every round.
:param individuals_per_contest: If set, overwrites the population setting for
number of individuals to have in a contest during the evaluation.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.evaluate', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.evaluate" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">contests_per_round</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">individuals_per_contest</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ContestPopulation&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Evaluate the individuals in the population.</span>
<span class="sd">    This evaluates the fitness of all individuals. For each round of</span>
<span class="sd">    evaluation, each individual participates in a given number of</span>
<span class="sd">    contests, in which a given number of individuals take part.</span>
<span class="sd">    The resulting scores of these contests are summed to form the fitness.</span>
<span class="sd">    This means that the score of the individual is influenced by other</span>
<span class="sd">    chromosomes in the population.</span>
<span class="sd">    Note that in the `ContestPopulation` two settings are passed at</span>
<span class="sd">    initialisation which affect how we are evaluating individuals:</span>
<span class="sd">    contests_per_round and individuals_per_contest. You may overwrite them</span>
<span class="sd">    here if you wish.</span>
<span class="sd">    If lazy is True, the fitness is only evaluated when a fitness value</span>
<span class="sd">    is not yet known for all individuals.</span>
<span class="sd">    In most situations adding an explicit evaluation step is not needed, as</span>
<span class="sd">    lazy evaluation is implicitly included in the operations that need it</span>
<span class="sd">    (most notably in the survive operation).</span>
<span class="sd">    :param lazy: If True, do no re-evaluate the fitness if the fitness is known.</span>
<span class="sd">    :param contests_per_round: If set, overwrites the population setting for the</span>
<span class="sd">    number of contests there will be every round.</span>
<span class="sd">    :param individuals_per_contest: If set, overwrites the population setting for</span>
<span class="sd">    number of individuals to have in a contest during the evaluation.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">contests_per_round</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">contests_per_round</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">contests_per_round</span>
    <span class="k">if</span> <span class="n">individuals_per_contest</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">individuals_per_contest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals_per_contest</span>
    <span class="k">if</span> <span class="n">lazy</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
        <span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">contests_per_round</span><span class="p">):</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">individuals_per_contest</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">generators</span> <span class="o">=</span> <span class="p">[</span><span class="n">islice</span><span class="p">(</span><span class="n">cycle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">),</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">competitors</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">generators</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)):</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">(</span><span class="o">*</span><span class="n">competitors</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">competitor</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">competitors</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
                <span class="n">competitor</span><span class="o">.</span><span class="n">fitness</span> <span class="o">+=</span> <span class="n">score</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.evolve">
    <p>def <span class="ident">evolve</span>(</p><p>self, evolution, n=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Evolve the population according to an Evolution.</p>
<p>:param evolution: Evolution to follow
:param n: Times to apply the evolution. Defaults to 1.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.evolve', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.evolve" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evolution</span><span class="p">:</span> <span class="s1">&#39;Evolution&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Evolve the population according to an Evolution.</span>
<span class="sd">    :param evolution: Evolution to follow</span>
<span class="sd">    :param n: Times to apply the evolution. Defaults to 1.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">evo_batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">evolution</span><span class="p">:</span>
            <span class="n">step</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.filter">
    <p>def <span class="ident">filter</span>(</p><p>self, func, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a filter step to the Evolution.</p>
<p>Filters the individuals in the population using the provided function.
Resets the fitness of all individuals.</p>
<p>:param func: Function to filter the individuals in the population by,
    which returns a boolean when called on an individual.
:param kwargs: Arguments to pass to the function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.filter', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.filter" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add a filter step to the Evolution.</span>
<span class="sd">    Filters the individuals in the population using the provided function.</span>
<span class="sd">    Resets the fitness of all individuals.</span>
<span class="sd">    :param func: Function to filter the individuals in the population by,</span>
<span class="sd">        which returns a boolean when called on an individual.</span>
<span class="sd">    :param kwargs: Arguments to pass to the function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Population</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.log">
    <p>def <span class="ident">log</span>(</p><p>self, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Logs a population. If a Population object was initialized with a logger
object then you may specify how logging is handled. The base logging
operation just logs to standard out.</p>
<p>:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.log', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.log" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logs a population. If a Population object was initialized with a logger</span>
<span class="sd">    object then you may specify how logging is handled. The base logging</span>
<span class="sd">    operation just logs to standard out.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.map">
    <p>def <span class="ident">map</span>(</p><p>self, func, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Apply the provided function to each individual in the population.</p>
<p>Resets the fitness of all individuals.</p>
<p>:param func: A function to apply to each individual in the population,
    which when called returns a modified individual.
:param kwargs: Arguments to pass to the function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.map', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Individual</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Apply the provided function to each individual in the population.</span>
<span class="sd">    Resets the fitness of all individuals.</span>
<span class="sd">    :param func: A function to apply to each individual in the population,</span>
<span class="sd">        which when called returns a modified individual.</span>
<span class="sd">    :param kwargs: Arguments to pass to the function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Population</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.mutate">
    <p>def <span class="ident">mutate</span>(</p><p>self, mutate_function, probability=1.0, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Mutate the chromosome of each individual.</p>
<p>:param mutate_function: Function that accepts a chromosome and returns
    a mutated chromosome.
:param probability: Probability that the individual mutates.
    The function is only applied in the given fraction of cases.
    Defaults to 1.0.
:param kwargs: Arguments to pass to the mutation function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.mutate', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.mutate" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
           <span class="n">mutate_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
           <span class="n">probability</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Mutate the chromosome of each individual.</span>
<span class="sd">    :param mutate_function: Function that accepts a chromosome and returns</span>
<span class="sd">        a mutated chromosome.</span>
<span class="sd">    :param probability: Probability that the individual mutates.</span>
<span class="sd">        The function is only applied in the given fraction of cases.</span>
<span class="sd">        Defaults to 1.0.</span>
<span class="sd">    :param kwargs: Arguments to pass to the mutation function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
        <span class="n">individual</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">mutate_function</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.reset_fitness">
    <p>def <span class="ident">reset_fitness</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Reset the fitness of all individuals.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.reset_fitness', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.reset_fitness" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">reset_fitness</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reset the fitness of all individuals.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
        <span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">=</span> <span class="bp">None</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.survive">
    <p>def <span class="ident">survive</span>(</p><p>self, fraction=None, n=None, luck=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Let part of the population survive.</p>
<p>Remove part of the population. If both fraction and n are specified,
the minimum resulting population size is taken. Resets the fitness
of all individuals.</p>
<p>:param fraction: Fraction of the original population that survives.
    Defaults to None.
:param n: Number of individuals of the population that survive.
    Defaults to None.
:param luck: If True, individuals randomly survive (with replacement!)
    with chances proportional to their fitness. Defaults to False.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.survive', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.survive" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">luck</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;ContestPopulation&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Let part of the population survive.</span>
<span class="sd">    Remove part of the population. If both fraction and n are specified,</span>
<span class="sd">    the minimum resulting population size is taken. Resets the fitness</span>
<span class="sd">    of all individuals.</span>
<span class="sd">    :param fraction: Fraction of the original population that survives.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    :param n: Number of individuals of the population that survive.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    :param luck: If True, individuals randomly survive (with replacement!)</span>
<span class="sd">        with chances proportional to their fitness. Defaults to False.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Population</span><span class="o">.</span><span class="n">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">fraction</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">luck</span><span class="o">=</span><span class="n">luck</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">reset_fitness</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># If we return the result of Population.survive PyCharm complains that it is of type &#39;Population&#39;</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="evol.population.ContestPopulation.chromosomes" class="name">var <span class="ident">chromosomes</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.ContestPopulation.contests_per_round" class="name">var <span class="ident">contests_per_round</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.ContestPopulation.current_best" class="name">var <span class="ident">current_best</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.ContestPopulation.current_worst" class="name">var <span class="ident">current_worst</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.ContestPopulation.individuals_per_contest" class="name">var <span class="ident">individuals_per_contest</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.generate">
    <p>def <span class="ident">generate</span>(</p><p>cls, init_function, eval_function, size=100, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate a population from an initialisation function.</p>
<p>:param init_function: Function that returns a chromosome.
:param eval_function: Function that reduces a chromosome to a fitness.
:param size: Number of individuals to generate. Defaults to 100.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.generate', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.generate" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
             <span class="n">init_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">],</span>
             <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
             <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generate a population from an initialisation function.</span>
<span class="sd">    :param init_function: Function that returns a chromosome.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param size: Number of individuals to generate. Defaults to 100.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chromosomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_function</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="n">chromosomes</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.ContestPopulation.load">
    <p>def <span class="ident">load</span>(</p><p>cls, target, eval_function, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Load a population from a checkpoint.</p>
<p>:param target: Path to checkpoint directory or file.
:param eval_function: Function that reduces a chromosome to a fitness.
:param kwargs: Any argument the init method accepts.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.ContestPopulation.load', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.ContestPopulation.load" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
         <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
         <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Load a population from a checkpoint.</span>
<span class="sd">    :param target: Path to checkpoint directory or file.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param kwargs: Any argument the init method accepts.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="p">[],</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="evol.population.Population" class="name">class <span class="ident">Population</span></p>
      
  
    <div class="desc"><p>Population of Individuals</p>
<p>:param chromosomes: Iterable of initial chromosomes of the Population.
:param eval_function: Function that reduces a chromosome to a fitness.
:param maximize: If True, fitness will be maximized, otherwise minimized.
    Defaults to True.
:param logger: Logger object for the Population. If None, a new BaseLogger
    is created. Defaults to None.
:param generation: Generation of the Population. Defaults to 0.
:param intended_size: Intended size of the Population. The population will
    be replenished to this size by .breed(). Defaults to the number of
    chromosomes provided.
:param checkpoint_target: Target for the serializer of the Population. If
    a serializer is provided, this target is ignored. Defaults to None.
:param serializer: Serializer for the Population. If None, a new
    SimpleSerializer is created. Defaults to None.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Population</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Population of Individuals</span>

<span class="sd">    :param chromosomes: Iterable of initial chromosomes of the Population.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param maximize: If True, fitness will be maximized, otherwise minimized.</span>
<span class="sd">        Defaults to True.</span>
<span class="sd">    :param logger: Logger object for the Population. If None, a new BaseLogger</span>
<span class="sd">        is created. Defaults to None.</span>
<span class="sd">    :param generation: Generation of the Population. Defaults to 0.</span>
<span class="sd">    :param intended_size: Intended size of the Population. The population will</span>
<span class="sd">        be replenished to this size by .breed(). Defaults to the number of</span>
<span class="sd">        chromosomes provided.</span>
<span class="sd">    :param checkpoint_target: Target for the serializer of the Population. If</span>
<span class="sd">        a serializer is provided, this target is ignored. Defaults to None.</span>
<span class="sd">    :param serializer: Serializer for the Population. If None, a new</span>
<span class="sd">        SimpleSerializer is created. Defaults to None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">chromosomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
                 <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">maximize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">generation</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">intended_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">checkpoint_target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">serializer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid4</span><span class="p">())[:</span><span class="mi">6</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span> <span class="o">=</span> <span class="n">eval_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generation</span> <span class="o">=</span> <span class="n">generation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Individual</span><span class="p">(</span><span class="n">chromosome</span><span class="o">=</span><span class="n">chromosome</span><span class="p">)</span> <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">chromosomes</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">=</span> <span class="n">intended_size</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="o">=</span> <span class="n">maximize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span> <span class="ow">or</span> <span class="n">BaseLogger</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span> <span class="o">=</span> <span class="n">serializer</span> <span class="ow">or</span> <span class="n">SimpleSerializer</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">checkpoint_target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chromosomes</span><span class="p">,</span>
                                <span class="n">eval_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">,</span>
                                <span class="n">maximize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">,</span>
                                <span class="n">serializer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="p">,</span>
                                <span class="n">intended_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span><span class="p">,</span>
                                <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                                <span class="n">generation</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">generation</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Individual</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Individual</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="s2">&quot;&lt;Population with size {len(self)} at {id(self)}&gt;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Individual</span><span class="p">:</span>
        <span class="n">evaluated_individuals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">current_worst</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Individual</span><span class="p">:</span>
        <span class="n">evaluated_individuals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">evaluated_individuals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="k">else</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">chromosomes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">individual</span><span class="o">.</span><span class="n">chromosome</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                 <span class="n">init_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">],</span>
                 <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
                 <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generate a population from an initialisation function.</span>

<span class="sd">        :param init_function: Function that returns a chromosome.</span>
<span class="sd">        :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">        :param size: Number of individuals to generate. Defaults to 100.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chromosomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_function</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="n">chromosomes</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
             <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Load a population from a checkpoint.</span>

<span class="sd">        :param target: Path to checkpoint directory or file.</span>
<span class="sd">        :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">        :param kwargs: Any argument the init method accepts.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="p">[],</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;pickle&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Checkpoint the population.</span>

<span class="sd">        :param target: Directory to write checkpoint to. If None, the Serializer default target is taken,</span>
<span class="sd">            which can be provided upon initialisation. Defaults to None.</span>
<span class="sd">        :param method: One of &#39;pickle&#39; or &#39;json&#39;. When &#39;json&#39;, the chromosomes need to be json-serializable.</span>
<span class="sd">            Defaults to &#39;pickle&#39;.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">individuals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_individual_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">min_fitness</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">max_fitness</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Individual weights can not be computed if the individuals are not evaluated.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_fitness</span> <span class="o">==</span> <span class="n">max_fitness</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">individual</span><span class="o">.</span><span class="n">fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_fitness</span> <span class="o">-</span> <span class="n">min_fitness</span><span class="p">)</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evolution</span><span class="p">:</span> <span class="s1">&#39;Evolution&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evolve the population according to an Evolution.</span>

<span class="sd">        :param evolution: Evolution to follow</span>
<span class="sd">        :param n: Times to apply the evolution. Defaults to 1.</span>
<span class="sd">        :return: Population</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">evo_batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">evolution</span><span class="p">:</span>
                <span class="n">step</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the individuals in the population.</span>

<span class="sd">        This evaluates the fitness of all individuals. If lazy is True, the</span>
<span class="sd">        fitness is only evaluated when a fitness value is not yet known. In</span>
<span class="sd">        most situations adding an explicit evaluation step is not needed, as</span>
<span class="sd">        lazy evaluation is implicitly included in the operations that need it</span>
<span class="sd">        (most notably in the survive operation).</span>

<span class="sd">        :param lazy: If True, do no re-evaluate the fitness if the fitness is known.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">eval_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="n">lazy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_documented_best</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the provided function to the population.</span>

<span class="sd">        :param func: A function to apply to the population, which returns the (modified) population.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Individual</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Apply the provided function to each individual in the population.</span>

<span class="sd">        :param func: A function to apply to each individual in the population,</span>
<span class="sd">            which when called returns a modified individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">individual</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a filter step to the Evolution.</span>

<span class="sd">        Filters the individuals in the population using the provided function.</span>

<span class="sd">        :param func: Function to filter the individuals in the population by,</span>
<span class="sd">            which returns a boolean when called on an individual.</span>
<span class="sd">        :param kwargs: Arguments to pass to the function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">individual</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">individual</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">luck</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Let part of the population survive.</span>

<span class="sd">        Remove part of the population. If both fraction and n are specified,</span>
<span class="sd">        the minimum resulting population size is taken.</span>

<span class="sd">        :param fraction: Fraction of the original population that survives.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param n: Number of individuals of the population that survive.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param luck: If True, individuals randomly survive (with replacement!)</span>
<span class="sd">            with chances proportional to their fitness. Defaults to False.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fraction</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;everyone survives! must provide either &quot;fraction&quot; and/or &quot;n&quot;.&#39;</span><span class="p">)</span>
            <span class="n">resulting_size</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">resulting_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resulting_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)),</span> <span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resulting_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no one survived!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resulting_size</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;everyone survives! must provide &quot;fraction&quot; and/or &quot;n&quot; &lt; population size&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">luck</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">choices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">resulting_size</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_individual_weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_individuals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">sorted_individuals</span><span class="p">[:</span><span class="n">resulting_size</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">breed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">parent_picker</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Individual</span><span class="p">]],</span>
              <span class="n">combiner</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
              <span class="n">population_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Create new individuals by combining existing individuals.</span>

<span class="sd">        :param parent_picker: Function that selects parents from a collection of individuals.</span>
<span class="sd">        :param combiner: Function that combines chromosomes into a new</span>
<span class="sd">            chromosome. Must be able to handle the number of chromosomes</span>
<span class="sd">            that the combiner returns.</span>
<span class="sd">        :param population_size: Intended population size after breeding.</span>
<span class="sd">            If None, take the previous intended population size.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        :param kwargs: Kwargs to pass to the parent_picker and combiner.</span>
<span class="sd">            Arguments are only passed to the functions if they accept them.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">population_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">=</span> <span class="n">population_size</span>
        <span class="n">offspring</span> <span class="o">=</span> <span class="n">offspring_generator</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
                                        <span class="n">parent_picker</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">parent_picker</span><span class="p">),</span>
                                        <span class="n">combiner</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">combiner</span><span class="p">),</span>
                                        <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
               <span class="n">mutate_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
               <span class="n">probability</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Mutate the chromosome of each individual.</span>

<span class="sd">        :param mutate_function: Function that accepts a chromosome and returns</span>
<span class="sd">            a mutated chromosome.</span>
<span class="sd">        :param probability: Probability that the individual mutates.</span>
<span class="sd">            The function is only applied in the given fraction of cases.</span>
<span class="sd">            Defaults to 1.0.</span>
<span class="sd">        :param kwargs: Arguments to pass to the mutation function.</span>
<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
            <span class="n">individual</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">mutate_function</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logs a population. If a Population object was initialized with a logger</span>
<span class="sd">        object then you may specify how logging is handled. The base logging</span>
<span class="sd">        operation just logs to standard out.</span>

<span class="sd">        :return: self</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="bp">None</span><span class="p">],</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs a callback function on the population. Can be used for</span>
<span class="sd">        custom logging/checkpointing.</span>
<span class="sd">        :param callback_function: Function that accepts the population</span>
<span class="sd">        as a first argument.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">callback_function</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_update_documented_best</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the documented best&quot;&quot;&quot;</span>
        <span class="n">current_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_best</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="ow">and</span> <span class="n">current_best</span><span class="o">.</span><span class="n">fitness</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span><span class="o">.</span><span class="n">fitness</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="ow">and</span> <span class="n">current_best</span><span class="o">.</span><span class="n">fitness</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span><span class="o">.</span><span class="n">fitness</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">current_best</span><span class="p">)</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#evol.population.Population">Population</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="evol.population.Population.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, chromosomes, eval_function, maximize=True, logger=None, generation=0, intended_size=None, checkpoint_target=None, serializer=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize self.  See help(type(self)) for accurate signature.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.__init__', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
             <span class="n">chromosomes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
             <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
             <span class="n">maximize</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="n">logger</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">generation</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
             <span class="n">intended_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">checkpoint_target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">serializer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid4</span><span class="p">())[:</span><span class="mi">6</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">documented_best</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span> <span class="o">=</span> <span class="n">eval_function</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">generation</span> <span class="o">=</span> <span class="n">generation</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Individual</span><span class="p">(</span><span class="n">chromosome</span><span class="o">=</span><span class="n">chromosome</span><span class="p">)</span> <span class="k">for</span> <span class="n">chromosome</span> <span class="ow">in</span> <span class="n">chromosomes</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">=</span> <span class="n">intended_size</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">maximize</span> <span class="o">=</span> <span class="n">maximize</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logger</span> <span class="ow">or</span> <span class="n">BaseLogger</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span> <span class="o">=</span> <span class="n">serializer</span> <span class="ow">or</span> <span class="n">SimpleSerializer</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">checkpoint_target</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.apply">
    <p>def <span class="ident">apply</span>(</p><p>self, func, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Apply the provided function to the population.</p>
<p>:param func: A function to apply to the population, which returns the (modified) population.
:param kwargs: Arguments to pass to the function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.apply', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.apply" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Apply the provided function to the population.</span>
<span class="sd">    :param func: A function to apply to the population, which returns the (modified) population.</span>
<span class="sd">    :param kwargs: Arguments to pass to the function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.breed">
    <p>def <span class="ident">breed</span>(</p><p>self, parent_picker, combiner, population_size=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Create new individuals by combining existing individuals.</p>
<p>:param parent_picker: Function that selects parents from a collection of individuals.
:param combiner: Function that combines chromosomes into a new
    chromosome. Must be able to handle the number of chromosomes
    that the combiner returns.
:param population_size: Intended population size after breeding.
    If None, take the previous intended population size.
    Defaults to None.
:param kwargs: Kwargs to pass to the parent_picker and combiner.
    Arguments are only passed to the functions if they accept them.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.breed', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.breed" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">breed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
          <span class="n">parent_picker</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Individual</span><span class="p">]],</span>
          <span class="n">combiner</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
          <span class="n">population_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
          <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Create new individuals by combining existing individuals.</span>
<span class="sd">    :param parent_picker: Function that selects parents from a collection of individuals.</span>
<span class="sd">    :param combiner: Function that combines chromosomes into a new</span>
<span class="sd">        chromosome. Must be able to handle the number of chromosomes</span>
<span class="sd">        that the combiner returns.</span>
<span class="sd">    :param population_size: Intended population size after breeding.</span>
<span class="sd">        If None, take the previous intended population size.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    :param kwargs: Kwargs to pass to the parent_picker and combiner.</span>
<span class="sd">        Arguments are only passed to the functions if they accept them.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">population_size</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">=</span> <span class="n">population_size</span>
    <span class="n">offspring</span> <span class="o">=</span> <span class="n">offspring_generator</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span>
                                    <span class="n">parent_picker</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">parent_picker</span><span class="p">),</span>
                                    <span class="n">combiner</span><span class="o">=</span><span class="n">select_arguments</span><span class="p">(</span><span class="n">combiner</span><span class="p">),</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">offspring</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">intended_size</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)))</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.callback">
    <p>def <span class="ident">callback</span>(</p><p>self, callback_function, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Performs a callback function on the population. Can be used for
custom logging/checkpointing.
:param callback_function: Function that accepts the population
as a first argument.
:return:</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.callback', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.callback" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="s1">&#39;Population&#39;</span><span class="p">],</span> <span class="bp">None</span><span class="p">],</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs a callback function on the population. Can be used for</span>
<span class="sd">    custom logging/checkpointing.</span>
<span class="sd">    :param callback_function: Function that accepts the population</span>
<span class="sd">    as a first argument.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">callback_function</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.checkpoint">
    <p>def <span class="ident">checkpoint</span>(</p><p>self, target=None, method=&#39;pickle&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Checkpoint the population.</p>
<p>:param target: Directory to write checkpoint to. If None, the Serializer default target is taken,
    which can be provided upon initialisation. Defaults to None.
:param method: One of 'pickle' or 'json'. When 'json', the chromosomes need to be json-serializable.
    Defaults to 'pickle'.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.checkpoint" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;pickle&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Checkpoint the population.</span>
<span class="sd">    :param target: Directory to write checkpoint to. If None, the Serializer default target is taken,</span>
<span class="sd">        which can be provided upon initialisation. Defaults to None.</span>
<span class="sd">    :param method: One of &#39;pickle&#39; or &#39;json&#39;. When &#39;json&#39;, the chromosomes need to be json-serializable.</span>
<span class="sd">        Defaults to &#39;pickle&#39;.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">individuals</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.evaluate">
    <p>def <span class="ident">evaluate</span>(</p><p>self, lazy=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Evaluate the individuals in the population.</p>
<p>This evaluates the fitness of all individuals. If lazy is True, the
fitness is only evaluated when a fitness value is not yet known. In
most situations adding an explicit evaluation step is not needed, as
lazy evaluation is implicitly included in the operations that need it
(most notably in the survive operation).</p>
<p>:param lazy: If True, do no re-evaluate the fitness if the fitness is known.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.evaluate', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.evaluate" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lazy</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Evaluate the individuals in the population.</span>
<span class="sd">    This evaluates the fitness of all individuals. If lazy is True, the</span>
<span class="sd">    fitness is only evaluated when a fitness value is not yet known. In</span>
<span class="sd">    most situations adding an explicit evaluation step is not needed, as</span>
<span class="sd">    lazy evaluation is implicitly included in the operations that need it</span>
<span class="sd">    (most notably in the survive operation).</span>
<span class="sd">    :param lazy: If True, do no re-evaluate the fitness if the fitness is known.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
        <span class="n">individual</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">eval_function</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">,</span> <span class="n">lazy</span><span class="o">=</span><span class="n">lazy</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_update_documented_best</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.evolve">
    <p>def <span class="ident">evolve</span>(</p><p>self, evolution, n=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Evolve the population according to an Evolution.</p>
<p>:param evolution: Evolution to follow
:param n: Times to apply the evolution. Defaults to 1.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.evolve', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.evolve" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evolution</span><span class="p">:</span> <span class="s1">&#39;Evolution&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Evolve the population according to an Evolution.</span>
<span class="sd">    :param evolution: Evolution to follow</span>
<span class="sd">    :param n: Times to apply the evolution. Defaults to 1.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">evo_batch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">evolution</span><span class="p">:</span>
            <span class="n">step</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.filter">
    <p>def <span class="ident">filter</span>(</p><p>self, func, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a filter step to the Evolution.</p>
<p>Filters the individuals in the population using the provided function.</p>
<p>:param func: Function to filter the individuals in the population by,
    which returns a boolean when called on an individual.
:param kwargs: Arguments to pass to the function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.filter', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.filter" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">bool</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add a filter step to the Evolution.</span>
<span class="sd">    Filters the individuals in the population using the provided function.</span>
<span class="sd">    :param func: Function to filter the individuals in the population by,</span>
<span class="sd">        which returns a boolean when called on an individual.</span>
<span class="sd">    :param kwargs: Arguments to pass to the function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">individual</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">individual</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.log">
    <p>def <span class="ident">log</span>(</p><p>self, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Logs a population. If a Population object was initialized with a logger
object then you may specify how logging is handled. The base logging
operation just logs to standard out.</p>
<p>:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.log', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.log" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Logs a population. If a Population object was initialized with a logger</span>
<span class="sd">    object then you may specify how logging is handled. The base logging</span>
<span class="sd">    operation just logs to standard out.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">population</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.map">
    <p>def <span class="ident">map</span>(</p><p>self, func, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Apply the provided function to each individual in the population.</p>
<p>:param func: A function to apply to each individual in the population,
    which when called returns a modified individual.
:param kwargs: Arguments to pass to the function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.map', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.map" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Individual</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Apply the provided function to each individual in the population.</span>
<span class="sd">    :param func: A function to apply to each individual in the population,</span>
<span class="sd">        which when called returns a modified individual.</span>
<span class="sd">    :param kwargs: Arguments to pass to the function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">individual</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.mutate">
    <p>def <span class="ident">mutate</span>(</p><p>self, mutate_function, probability=1.0, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Mutate the chromosome of each individual.</p>
<p>:param mutate_function: Function that accepts a chromosome and returns
    a mutated chromosome.
:param probability: Probability that the individual mutates.
    The function is only applied in the given fraction of cases.
    Defaults to 1.0.
:param kwargs: Arguments to pass to the mutation function.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.mutate', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.mutate" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
           <span class="n">mutate_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
           <span class="n">probability</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Mutate the chromosome of each individual.</span>
<span class="sd">    :param mutate_function: Function that accepts a chromosome and returns</span>
<span class="sd">        a mutated chromosome.</span>
<span class="sd">    :param probability: Probability that the individual mutates.</span>
<span class="sd">        The function is only applied in the given fraction of cases.</span>
<span class="sd">        Defaults to 1.0.</span>
<span class="sd">    :param kwargs: Arguments to pass to the mutation function.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">individual</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">:</span>
        <span class="n">individual</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">mutate_function</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.survive">
    <p>def <span class="ident">survive</span>(</p><p>self, fraction=None, n=None, luck=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Let part of the population survive.</p>
<p>Remove part of the population. If both fraction and n are specified,
the minimum resulting population size is taken.</p>
<p>:param fraction: Fraction of the original population that survives.
    Defaults to None.
:param n: Number of individuals of the population that survive.
    Defaults to None.
:param luck: If True, individuals randomly survive (with replacement!)
    with chances proportional to their fitness. Defaults to False.
:return: self</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.survive', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.survive" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">survive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">luck</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Let part of the population survive.</span>
<span class="sd">    Remove part of the population. If both fraction and n are specified,</span>
<span class="sd">    the minimum resulting population size is taken.</span>
<span class="sd">    :param fraction: Fraction of the original population that survives.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    :param n: Number of individuals of the population that survive.</span>
<span class="sd">        Defaults to None.</span>
<span class="sd">    :param luck: If True, individuals randomly survive (with replacement!)</span>
<span class="sd">        with chances proportional to their fitness. Defaults to False.</span>
<span class="sd">    :return: self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fraction</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;everyone survives! must provide either &quot;fraction&quot; and/or &quot;n&quot;.&#39;</span><span class="p">)</span>
        <span class="n">resulting_size</span> <span class="o">=</span> <span class="n">n</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">resulting_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resulting_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">fraction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">)),</span> <span class="n">n</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">lazy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resulting_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;no one survived!&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">resulting_size</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;everyone survives! must provide &quot;fraction&quot; and/or &quot;n&quot; &lt; population size&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">luck</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">choices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">resulting_size</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_individual_weights</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sorted_individuals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">individuals</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">fitness</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">maximize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">sorted_individuals</span><span class="p">[:</span><span class="n">resulting_size</span><span class="p">]</span>
    <span class="k">return</span> <span class="bp">self</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="evol.population.Population.chromosomes" class="name">var <span class="ident">chromosomes</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.current_best" class="name">var <span class="ident">current_best</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.current_worst" class="name">var <span class="ident">current_worst</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.documented_best" class="name">var <span class="ident">documented_best</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.eval_function" class="name">var <span class="ident">eval_function</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.generation" class="name">var <span class="ident">generation</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.id" class="name">var <span class="ident">id</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.individuals" class="name">var <span class="ident">individuals</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.intended_size" class="name">var <span class="ident">intended_size</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.logger" class="name">var <span class="ident">logger</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.maximize" class="name">var <span class="ident">maximize</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="evol.population.Population.serializer" class="name">var <span class="ident">serializer</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="evol.population.Population.generate">
    <p>def <span class="ident">generate</span>(</p><p>cls, init_function, eval_function, size=100, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Generate a population from an initialisation function.</p>
<p>:param init_function: Function that returns a chromosome.
:param eval_function: Function that reduces a chromosome to a fitness.
:param size: Number of individuals to generate. Defaults to 100.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.generate', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.generate" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
             <span class="n">init_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">],</span>
             <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
             <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Generate a population from an initialisation function.</span>
<span class="sd">    :param init_function: Function that returns a chromosome.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param size: Number of individuals to generate. Defaults to 100.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chromosomes</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_function</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="n">chromosomes</span><span class="p">,</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="evol.population.Population.load">
    <p>def <span class="ident">load</span>(</p><p>cls, target, eval_function, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Load a population from a checkpoint.</p>
<p>:param target: Path to checkpoint directory or file.
:param eval_function: Function that reduces a chromosome to a fitness.
:param kwargs: Any argument the init method accepts.
:return: Population</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-evol.population.Population.load', this);">Show source &equiv;</a></p>
  <div id="source-evol.population.Population.load" class="source">
    <div class="codehilite"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
         <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
         <span class="n">eval_function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Population&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Load a population from a checkpoint.</span>
<span class="sd">    :param target: Path to checkpoint directory or file.</span>
<span class="sd">    :param eval_function: Function that reduces a chromosome to a fitness.</span>
<span class="sd">    :param kwargs: Any argument the init method accepts.</span>
<span class="sd">    :return: Population</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chromosomes</span><span class="o">=</span><span class="p">[],</span> <span class="n">eval_function</span><span class="o">=</span><span class="n">eval_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">individuals</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">serializer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>

  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
